######################################################
#                                                    #
#        軍人将棋　for DXライブラリ (未完成)         #
#                                                    #
#                                                    #
#                    2017/7/28     製作者: Sugunisu  #
#                                                    #
######################################################



●このゲームについて
軍人将棋をオンラインで遊ぶことができるようにしたものです.
軍人将棋の大まかなルールに関してはネット上のいろんなサイトで
解説されているのでそちらを参照してください.

ゲームモードについては以下の4つのモードが用意される予定です.

・CPU対戦(ローカル対戦) (未)
・ネット対戦(ホスト)
・ネット対戦(ゲスト)
・審判　　　　　　　　　(未)

対戦後は実際にどのようにコマが動いていたかが確認できる
棋譜モードを用意する予定です.(未実装)



●コンパイルについて
Dev-C++のプロジェクトでコンパイラ名を「DXLib」として設計しています
Dev-C++での環境設定についてはこちらを参考にしてください
http://dxlib.96.lt/dxlib/use/dxuse_gcc.html

Makefileが残っているので
DXライブラリを導入すればMinGWのみでもコンパイルできます

VisualStudio等でコンパイルする場合は以下のサイトをご覧ください
http://dxlib.o.oo7.jp/dxuse.html




●このプログラムを制作する目的
・オブジェクト指向プログラミングにおける様々な技術の習得
　　(MVCモデルを用いたフォームオブジェクトの原理の学習,
　 　リスナークラスを用いたオブジェクト間メッセージ交換等)

・DXライブラリで開発を促進するためのライブラリ開発(シーン変更,MVCモデル等)

・人の協力を得ずに自力でどれだけできるかを再確認すると共に,
　完成後に公開し人に批評してもらうためのたたき台とするため.

・友達と遊ぶため.

・ドワンゴの採用時の「技術アピール」として提出するため.



●現在できているところ
・「設定」シーン以外のそれぞれのシーンでのMVC
・制作した通信プロトコルでのやり取り
・ネット対戦(ローカル同士)での一通りのプレイ



●実装に関して

・DXライブラリに関して
DXライブラリは山田巧様が制作したDirectXのラッパである.
キーボード,マウス,ジョイパッド入力や通信,3D処理,等
一通りのゲーム制作のための処理が揃っている.
ただし,ボタン等のゲーム制作に欠かせないパーツがあるわけではなく,
それを制作することが目標の一つになっている.(フォームオブジェクトの制作)

・操作端末
軍人将棋は相手のコマが見えない.
解決法として,お互いにメモリ上にロードしてそれぞれの端末で処理することもできるが,
メモリの中身を覗くことで不正に敵のコマの配置を知ることができてしまう.
そこで審判を別に置く必要があった.
また,サーバーを立てずに手軽に楽しめるようにホストに審判を置き戦えるようにもしたい.
そうなるとコマの移動を相手に知らせる時に通信か内部データ受け渡しかが変わってしまう.
それを吸収するためにMessengerクラスを用意した
MessengerクラスにはTCPMessengerとLocalMessengerが継承されてありそれぞれ,
通信用,内部データ受け渡し用になっている.
そして,プレイヤーと審判もParticipantクラスを継承したPlayerクラスとJudgeクラスとしている.
2つのPlayerクラスはJudgeクラスに繋がるMessengerクラスを所有し
JudgeクラスはそれぞれのPlayerクラスに繋がるMessengerクラスを所有していることになる.


・MVCモデルにおけるフォームオブジェクトを利用可能にする設計
フォームオブジェクトはsource/formObject/に格納している.
ViewではformObjectをスタックに格納し,スタックした順に表示している
(=最後にスタックしたものが一番上に表示される.).
マウスがある部分のオブジェクトにはOnUpdate,それ以外にはOffUpdateが適用される
(重なっていれば表示されている中で一番上にフォーカスがあるものになる.).
それぞれのオブジェクトにはコールバック用に親クラスを設定していて,
例えばボタンであればクリックが離れた瞬間にView側のOnClickに自分のポインタを送り,
それに対応した動きをしてもらう形になっている.
Controlerクラスは入出力やView側からModel側に情報を送りたいときに利用する

・シーンとMVCモデル
シーンはSceneMgrクラスが管理してシーン変更の際はPassDataMapクラスを経由しデータを
受け渡しする,シーンクラスはMVCモデルによるControlerクラスと結合する.

・プロトコル

第一段階 
　Player側からコマ情報を左上からコマIDをハイフンを挟んで列挙してJudgeに送る,
　Judgeが両方のを入力を受け付けたら先攻か後攻かを"W","B"の一文字をそれぞれに送る.

第二段階
　手番を持つPlayerは動かすコマの移動元と移動後のマス(移動情報)を送る(例:B4B5).
　Judgeは二人に移動情報と勝利情報を送る.
　勝利情報は勝ったほうが先攻か,後攻か,引き分けか(W,B,D)その後勝ったプレイヤーには,
　勝利した相手のコマのコマID,引き分けなら引き分けた相手のコマIDがつく.
　これを勝利条件を満たすまで行う.

第三段階
　どちらかが勝利したら終わりを表す"END"と勝者(W,B),最初の相手のコマ位置を繋げて返す.




※なお,手探りながら作っているため,統一感がない部分が多々あります




●今後のTO DO (優先度順)

<お互いにルールを守れば取り合えず遊べる>
・ゲーム終了後にシーンが変更できるようにする
・対戦相手のIPとPortをゲーム時に入力できるようにする(今はローカル)

<プレイヤーにルールを破ることなく取り合えず遊べる>
・動ける場所にしか動かせないようにする

<プレイヤーが操作しやすくする>
・動かせない場所や配置できない等のマスを暗くする
・戦闘時の戦闘結果の表示
・残りコマ数の表示
・ゲーム終了の合図を通信プロトコルに埋め込む
・終了後に敵コマを公開状態で棋譜を確認できるようにする

<安全にする>
・どんな値にも対応できるよう例外処理を加える
・マスをstringではなくクラスで対応させる
・デストラクタで確保したメモリを手動で開放させる

<目標に向けて>
・Playerクラスを継承した適当なAIを作ってコンピュータと戦えるようにする
・Playerクラス中のMessengerクラスは入出力なのでPlayerControlerクラスに配置する
・MVCはMVCBaseを使った抽象クラスを経由させる
・JudgeクラスもMVCに準ずる形にする


<追加目標>
・ネットワーク用の通信内容をパッケージ化(全サイズ,[ID,サイズ,通信データ],[...],...)
  として,複数の通信内容を送れるようにする(チャット等の機能をつけるため)
・ネットワークで受けたデータを蓄積する(FIFO)
・BGM,SE等のマネージャークラスを作り管理クラスに持たせる
・テキストボックスなどフォームオブジェクトの充実
・その時の気分などでつけている命名規則の統一
・ソースコードが汚いので細分化,その場合わせのために作った関数等の除去


・・・




●現在の疑問点など

・MVCにおけるマウス等の入出力はControlerクラスに配置すべきであるが,
　マウスやキーボードはSingletonで設計していてViewに情報を渡す際はそれ用の構造体(クラス),
　あるいはポインタを渡さなければならない.
　しかし,コピーしてしまってはSingletonにした意味がなくなり,どうすべきかわからない.



